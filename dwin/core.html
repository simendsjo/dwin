<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>dwin.core</title>
        </head><body>
        <h1>dwin.core</h1>
        <!-- Generated by Ddoc from c:\d\ext\dwin\src\dwin\core.d -->
Helper module
<br><br>
<b>License:</b><br>
<a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a>
<br><br>
<b>Authors:</b><br>
<a href="mailto:simendsjo@gmail.com">Simen Endsjø</a>
<br><br>
<b>Source:</b><br>
<a href="https://github.com/simendsjo/dwin/tree/master/dwin/src/dwin/dwin.core.d">Source</a>
<br><br>

<dl><dt><big>TCHAR* <u>toWinStringz</u>(S)(S <i>str</i>);
</big></dt>
<dd>Converts a <font color=blue>string</font>, <font color=blue>wstring</font> or
<font color=blue>dstring</font> to a <b>null</b> terminated string for passing to win32 API
calls.<br><br>

</dd>
<dt><big>wchar[] <u>fromWinStringz</u>(wchar* <i>str</i>);
</big></dt>
<dd>Converts from a Win32 string to D string array. Removes the <b>null</b> terminator
if it exists.<br><br>

</dd>
<dt><big>class <u>Handle</u>;
</big></dt>
<dd>A safer way to store a win32 <u>HANDLE</u>. Asserts or throws an
exception if using a closed <u>HANDLE</u>.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>auto</font> h1 = <font color=blue>new</font> <u>Handle</u>(0); <font color=green>// asserts
</font><font color=blue>auto</font> h2 = <font color=blue>new</font> <u>Handle</u>(666); <font color=green>// asserts if invalid handle
</font><font color=blue>auto</font> h3 = <font color=blue>new</font> <u>Handle</u>(999);
h3.close();
<font color=blue>auto</font> handle = h3.handle; <font color=green>// asserts as handle is closed
</font>
<font color=blue>auto</font> h4 = <font color=blue>new</font> <u>Handle</u>(1010);
<font color=blue>auto</font> h5 = <font color=blue>new</font> <u>Handle</u>(1010);
h4.close();
handle = h5.handle; <font color=green>// asserts as h4 already closed the handle
</font></pre>
<br><br>

</dd>
<dt><big>template <u>EmbedHandle</u>(string name)</big></dt>
<dd>Embeds a private Handle instance as handle_<i>name</i>
<br><br>
You must initialize the handle in the constructor.

<br><br>
<b>Params:</b><br>
<table><tr><td>name</td>
<td>Handle name. This will create a getter and setter property with
           the same name. The getter will get the underlying
           <u>HANDLE</u> instance, while the setter will set the
           <u>Handle</u> instance.  The close function will be named
           <i>name</i>Close</td></tr>
</table><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>struct</font> S {
  <u>EmbedHandle</u>!<font color=red>"myHandle"</font>;

  <font color=blue>this</font>(HANDLE handle) {
    myHandle = <font color=blue>new</font> Handle(handle);
    <font color=blue>assert</font>(myHandle == handle);
  }
}

<font color=blue>auto</font> S = S(999); <font color=green>// 999 must be a valid handle, or else it asserts
</font><font color=blue>assert</font>(S.handle == 999);
S.myhandleClose();
<font color=blue>auto</font> h = S.handle; <font color=green>// assertion as handle is closed
</font></pre>
<br><br>

</dd>
<dt><big>template <u>EmbedScopedHandle</u>(string name)</big></dt>
<dd>As <u>EmbedHandle</u>, but also adds a destructor to close the
<u>Handle</u>.
<br><br>
<font color=red>BUGS:</font><br>
Because only one destructor can exist, you can only add it to a
<font color=blue>struct</font>/<font color=blue>class</font> that doesn't already contain
a destructor.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>struct</font> S {
    <font color=blue>mixin</font> <u>EmbedScopedHandle</u>!<font color=red>"myHandle"</font>;
    <font color=blue>this</font>(HANDLE handle) {
        myHandle = <font color=blue>new</font> Handle(handle);
    }
}

HANDLE handle = 999; <font color=green>// assume 999 is a valid handle
</font>{ <font color=blue>auto</font> s = S(handle);
  <font color=green>// do stuff with handle
</font>} <font color=green>// handle closes here
</font><font color=blue>auto</font> s = S(handle); <font color=green>// assertion as handle is closed
</font></pre>
<br><br>

</dd>
<dt><big>@system P <u>toUTFz</u>(P, S)(S <i>str</i>);
</big></dt>
<dd><font color=red>BUGS:</font><br>
STOLEN FROM PHOBOS TRUNK - REMOVE IN DMD 2.055!!
<br><br>

    Returns a C-style zero-terminated string equivalent to . 
    must not contain embedded 's as any C function will treat the first
     that it sees a the end of the string. If  is
    , then a string containing only  is returned.
<br><br>

     accepts any type of string and is templated on the type of
    character pointer that you wish to convert to. It will avoid allocating a
    new string if it can, but there's a decent chance that it will end up having
    to allocate a new string - particularly when dealing with character types
    other than .
<br><br>

    <font color=red>Warning 1:</font> If the result of  equals , then if
    anything alters the character one past the end of  (which is the
     character terminating the string), then the string won't be
    zero-terminated anymore. The most likely scenarios for that are if you
    append to  and no reallocation takes place or when  is a
    slice of a larger array, and you alter the character in the larger array
    which is one character past the end of . Another case where it could
    occur would be if you had a mutable character array immediately after
     in memory (for example, if they're member variables in a
    user-defined type with one declared right after the other) and that
    character array happened to start with . Such scenarios will never
    occur if you immediately use the zero-terminated string after calling
     and the C function using it doesn't keep a reference to it.
    Also, they are unlikely to occur even if you save the zero-terminated string
    (the cases above would be among the few examples of where it could happen).
    However, if you save the zero-terminate string and want to be absolutely
    certain that the string stays zero-terminated, then simply append a
     to the string and use its  property rather than calling
    .
<br><br>

    <font color=red>Warning 2:</font> When passing a character pointer to a C function, and the
    C function keeps it around for any reason, make sure that you keep a
    reference to it in your D code. Otherwise, it may go away during a garbage
    collection cycle and cause a nasty bug when the C code tries to use it.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>auto</font> p1 = <u>toUTFz</u>!(<font color=blue>char</font>*)(<font color=red>"hello world"</font>);
<font color=blue>auto</font> p2 = <u>toUTFz</u>!(<font color=blue>const</font>(<font color=blue>char</font>)*)(<font color=red>"hello world"</font>);
<font color=blue>auto</font> p3 = <u>toUTFz</u>!(<font color=blue>immutable</font>(<font color=blue>char</font>)*)(<font color=red>"hello world"</font>);
<font color=blue>auto</font> p4 = <u>toUTFz</u>!(<font color=blue>char</font>*)(<font color=red>"hello world"d</font>);
<font color=blue>auto</font> p5 = <u>toUTFz</u>!(<font color=blue>const</font>(<font color=blue>wchar</font>)*)(<font color=red>"hello world"</font>);
<font color=blue>auto</font> p6 = <u>toUTFz</u>!(<font color=blue>immutable</font>(<font color=blue>dchar</font>)*)(<font color=red>"hello world"w</font>);
</pre>
<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>. Copyright &copy; 2011-2011 by <a href="mailto:simendsjo@gmail.com">Simen Endsjø</a>, All Rights Reserved
</small>
        </body></html>
